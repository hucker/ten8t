""" This module contains the Ten8tResult class and some common result transformers. """

import itertools
import traceback
from collections import Counter
from dataclasses import asdict, dataclass, field
from operator import attrgetter
from typing import Any, Sequence

from .render import Ten8tMarkup
from .ten8t_exception import Ten8tException


@dataclass
class Ten8tResult:
    """
    Represents the outcome and metadata of a Ten8tFunction execution.

    This information should be enough to perform all filtering, analysis, and reporting.

    NOTE: There are optimization opportunities for the data class.  The assumption is that we
    will have 100's or 1000's of results and not millions.  As such, memory usage has not
    been a concern...thus having complete and detailed information has outweighed
    having small memory footprint.

    Attributes:
        status (bool | None): Execution status indicator.
        func_name (str): Name of the executed function.
        pkg_name (str): Package name containing the function.
        module_name (str): Module name containing the function.
        msg (str): Message intended for the user.
        info_msg (str): Additional informational message.
        warn_msg (str): Warning message from the execution.
        doc (str): Docstring of the executed function.
        runtime_sec (float): Runtime duration in seconds.
        except_ (Exception | None): Exception raised during execution, if any.
        traceback (str): Traceback of the exception, if raised.
        skipped (bool): Indicates whether execution was skipped.
        weight (float): Relative importance or weight assigned to this result.
        tag (str): Tag to categorize or identify the function.
        level (int): Level associated with the function's execution.
        phase (str): Execution phase indicator.
        count (int): Number of return values generated by the function.
        ruid (str): Unique identifier for the result instance.
        ttl_minutes (float): Result's time-to-live in minutes.
        mit_msg (str): Mitigation message, if applicable.
        owner_list (list[str]): List of owners or responsible parties.
        skip_on_none (bool): Flag indicating skipping when encountering None.
        fail_on_none (bool): Flag indicating failure when encountering None.
        summary_result (bool): Flag if this result represents a summary outcome.
        thread_id (str): Thread identifier where function executed.

    Methods:
        as_dict() -> dict:
            Converts instance attributes to a dictionary suitable for hashing or serialization.

        """

    status: bool | None = False

    # Name hierarchy
    func_name: str = ""
    pkg_name: str = ""
    module_name: str = ""

    # Output Message
    #   _msg has markup tags suitable for rendering  in any supported format  <<code>>Hello<</code>>
    #   _rendered has the text formated for the target format                 `Hello`
    #   _text has the text with all formatting tags removed                   Hello
    msg: str = ""
    msg_rendered: str = ""
    msg_text: str = ""

    info_msg: str = ""
    info_msg_rendered: str = ""
    info_msg_text: str = ""

    warn_msg: str = ""
    warn_msg_rendered: str = ""
    warn_msg_text: str = ""

    # Function Info
    doc: str = ""

    # Timing Info
    runtime_sec: float = 0.0

    # Error Info
    except_: Exception | None = None
    traceback: str = ""
    skipped: bool = False

    weight: float = 100.0

    # Attribute Info - This needs to be factored out?
    tag: str = ""
    level: int = 1
    phase: str = ""
    count: int = 0
    ruid: str = ""
    ttl_minutes: float = 0.0

    # Mitigations
    mit_msg: str = ""
    owner_list: list[str] = field(default_factory=list)

    # Bad parameters
    skip_on_none: bool = False
    fail_on_none: bool = False

    # Indicate summary results, so they can be filtered
    summary_result: bool = False

    # Thread id where function ran
    thread_id: str = ""

    mu = Ten8tMarkup()

    def __post_init__(self):
        # Automatically grab the traceback for better debugging.
        if self.except_ is not None and not self.traceback:
            self.traceback = traceback.format_exc()

    def as_dict(self) -> dict:
        """Convert the Ten8tResult instance to a dictionary."""
        d = asdict(self)

        # We want this dict to be hashable so we make this a string.
        # Place any other unhashable things here (including deleting them).
        d['except_'] = str(d['except_'])
        return d


# Shorthand
TR = Ten8tResult


# Result transformers do one of three things, nothing and pass the result on, modify the result
# or return None to indicate that the result should be dropped.  What follows are some
# common result transformers.

def passes_only(sr: Ten8tResult):
    """ Return only results that have pass status"""
    return sr if sr.status else None


def fails_only(sr: Ten8tResult):
    """Filters out successful results.

    Args:
        sr (Ten8tResult): The result to check.

    Returns:
        Ten8tResult: The result if it has failed, otherwise None.
    """
    return None if sr.status else sr


def remove_info(sr: Ten8tResult):
    """Filter out messages tagged as informational

    Args:
        sr (Ten8tResult): The result to check.

    Returns:
        Ten8tResult: The result if it has failed, otherwise None.
    """
    return None if sr.info_msg else sr


def warn_as_fail(sr: Ten8tResult):
    """Treats results with a warning message as failures.

    Args:
        sr (Ten8tResult): The result to check.

    Returns:
        Ten8tResult: The result with its status set to False if there's a warning message.
    """
    if sr.warn_msg:
        sr.status = False
    return sr


def results_as_dict(results: list[Ten8tResult]):
    """Converts a list of Ten8tResult to a list of dictionaries.

    Args:
        results (list[Ten8tResult]): The list of results to convert.

    Returns:
        list[Dict]: The list of dictionaries.
    """
    return [result.as_dict() for result in results]


def group_by(results: Sequence[Ten8tResult], keys: Sequence[str]) -> dict[str, Any]:
    """
    Groups a list of Ten8tResult by a list of keys.

    This function allows for arbitrary grouping of Ten8tResult using the keys of the
    Ten8tResult as the grouping criteria.  You can group in any order or depth with
    any number of keys.

    Args:
        results (Sequence[Ten8tResult]): The list of results to group.
        keys (Sequence[str]): The list of keys to group by.S

    """

    if not keys:
        raise Ten8tException("Empty key list for grouping results.")

    key = keys[0]
    key_func = attrgetter(key)

    # I do not believe this is an actual test case as it would require a bug in
    # the code.  I'm leaving it here for now.
    # if not all(hasattr(x, key) for x in results):
    #    raise ten8t.Ten8tValueError(f"All objects must have an attribute '{key}'")

    # Sort and group by the first key
    results = sorted(results, key=key_func)
    group_results: list[tuple[str, Any]] = [(k, list(g))
                                            for k, g in itertools.groupby(results, key=key_func)]

    # Recursively group by the remaining keys
    if len(keys) > 1:
        for i, (k, group) in enumerate(group_results):
            group_results[i] = (k, group_by(group, keys[1:]))

    return dict(group_results)


def overview(results: list[Ten8tResult]) -> str:
    """
    Returns an overview of the results.

    Args:
        results (list[Ten8tResult]): The list of results to summarize.

    Returns:
        str: A summary of the results.
    """

    result_counter = Counter(
        'skip' if result.skipped else
        'error' if result.except_ else
        'fail' if not result.status else
        'warn' if result.warn_msg else
        'pass'
        for result in results
    )

    total = len(results)
    passed = result_counter['pass']
    failed = result_counter['fail']
    errors = result_counter['error']
    skipped = result_counter['skip']
    warned = result_counter['warn']

    return f"Total: {total}, Passed: {passed}, Failed: {failed}, " \
           f"Errors: {errors}, Skipped: {skipped}, Warned: {warned}"
